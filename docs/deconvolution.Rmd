---
title: ""
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
---

<style>
body {
  text-align: justify
}
.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{css, echo=FALSE}
.watch-out {
  color: black;
}
```

```{r setup, include=FALSE}
# use rmarkdown::render_site(envir = knitr::knit_global())
knitr::opts_chunk$set(highlight = TRUE, echo = TRUE)
```

<br>

# ROI/Spot Deconvolution and Niche Clustering

Essentially, Regions of Interests (ROIs) and Spots include often some arbitrary of cells that are of multiple types. RNA Deconvolution is then incorporated to estimate the percentage/abundance of these cell types within each spot/ROI given a reference scRNAseq dataset. 

VoltRon includes wrapper commands for using popular RNA deconvolution methods such as [RCTD](https://www.nature.com/articles/s41587-021-00830-w) (**spot**), [SPOTlight](https://academic.oup.com/nar/article/49/9/e50/6129341) (**spot**) and [MuSiC](https://www.nature.com/articles/s41467-018-08023-x) (**ROI**), and return estimated abundances as additional assays within each layer. These novel assays then can be further processed and used for clustering to detect niches across multiple datatypes.  

<br>

## Import ST Data

We will now import the samples and merge them into one VoltRon object

```{r eval = FALSE, class.source="watch-out"}
library(VoltRon)

# import Visium data
Vis_A1 <- importVisium("hColon_N_A1/", sample_name = "Vis_A1")
Vis_B1 <- ImportVisium("hColon_T_B1/", sample_name = "Vis_B1")
Vis_C1 <- ImportVisium("hColon_N_C1/", sample_name = "Vis_C1")
Vis_D1 <- ImportVisium("hColon_T_D1/", sample_name = "Vis_D1")

# merge datasets
Vis_CRC <- list(Vis_A1, Vis_B1, Vis_C1, Vis_D1)
Vis_CRC <- merge(Vis_CRC[[1]], Vis_CRC[-1])
vrSpatialFeaturePlot(Vis_CRC, features = "Count", crop = TRUE, alpha = 1, ncol = 2)
```

```
VoltRon Object 
Vis_A1: 
  Layers: Section1 
Vis_B1: 
  Layers: Section1 
Vis_C1: 
  Layers: Section1 
Vis_D1: 
  Layers: Section1 
Assays: Visium(Main) 
```

<img width="65%" height="65%" src="images/decon_first_plot.png" class="center">

<br>

## Import scRNA data

We will now import the scRNA data for reference

```{r eval = FALSE, class.source="watch-out"}
library(Seurat)
scdata <- readRDS("GSE166555_uhlitz.rds")
meta.data <- read.table("GSE166555_meta_data.tsv", header = T, sep = "\t", na.strings = "NA", fill = TRUE)

# normalize RNA assay before Spot deconvolution
scdata <- Seurat::NormalizeData(scdata, assay = "RNA")

# Visualize
gtype <- DimPlot(scdata, reduction = "umap", label = T, group.by = "agg_minorcelltype") + NoLegend()
gsample <- DimPlot(scdata, reduction = "umap", label = F, group.by = "SampleType")
gsample | gtype
```

<img width="90%" height="90%" src="images/decon_singlecell.png" class="center">

<br>

## Spot Deconvolution with RCTD

In order to integrate the scRNA data and the Visium data sets within the VoltRon objects, we will use **RCTD** algorithm which is accessible with the [spacexr](https://github.com/dmcable/spacexr) package. For all layers with a Visium data, an additional assay within the same layer with **_decon** postfix will be created. 

```{r eval = FALSE, class.source="watch-out"}
# libraries for RCTD algorithm
library(spacexr)

# Spot Deconvolution
vrMainAssay(Vis_CRC) <- "Visium"
Vis_CRC <- getDeconvolution(Vis_CRC, sc.object = scdata_subset_tumor, sc.cluster = "minorcelltype", max_cores = 6)
Vis_CRC
```

```
VoltRon Object 
Vis_A1: 
  Layers: Section1 
Vis_B1: 
  Layers: Section1 
Vis_C1: 
  Layers: Section1 
Vis_D1: 
  Layers: Section1 
Assays: Visium(Main) Visium_decon
```

We can now switch to the **Visium_decon** assays where features are now cell types from the scRNA reference and the data values are cell types percentages in each spot. 

```{r eval = FALSE, class.source="watch-out"}
# Visualize
vrMainAssay(Vis_CRC) <- "Visium_decon"
vrSpatialFeaturePlot(Vis_CRC, features = "MyoFBs", crop = TRUE, ncol = 5, alpha = 1)
```

<br>

## Niche Clustering 

After creating the new cell type abundance assays, we can now process them for clustering. Cell type abundance can be realized as [compositional data](https://en.wikipedia.org/wiki/Compositional_data), hence we incorporate **centred log ratio (CLR)** transformation for normalizing these relative abundances.

```{r eval = FALSE, class.source="watch-out"}
# process
vrMainAssay(Vis_CRC) <- "Visium_decon"
Vis_CRC <- normalizeData(Vis_CRC, method = "CLR")
```

<br>

Using normalized cell type abundances, we generate k-nearest neighbor graphs and cluster the graph using leiden method.  

```{r eval = FALSE, class.source="watch-out"}
# assay
vrMainAssay(Vis_CRC) <- "Visium_decon"

# get neighbors
Vis_CRC <- getNeighbors(Vis_CRC, data.type = "norm", assay = "Visium_decon")

# get clustering
Vis_CRC <- getClusters(Vis_CRC, resolution = 0.4, label = "Decon_clusters")

# visualize
vrSpatialFeaturePlot(Vis_CRC, group.by = "Decon_clusters", crop = TRUE, alpha = 1)
```

<br>

## Visualization and Comparison

```{r eval = FALSE, class.source="watch-out"}
vrMainAssay(Vis_CRC) <- "Visium_decon"
vrHeatmapPlot(Vis_CRC, features = vrFeatures(Vis_CRC), group.by = "Decon_clusters")
```
